{"version":3,"sources":["webpack://bpdLogger/webpack/universalModuleDefinition","webpack://bpdLogger/webpack/bootstrap","webpack://bpdLogger/webpack/runtime/define property getters","webpack://bpdLogger/webpack/runtime/hasOwnProperty shorthand","webpack://bpdLogger/webpack/runtime/make namespace object","webpack://bpdLogger/./src/logger.ts","webpack://bpdLogger/./src/reporters/console.ts","webpack://bpdLogger/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","PROPERTIES","MESSAGE","ID","MODULE","METHOD","PERFORFMANCE","matchesLevel","level","systemLevel","levels","findIndex","l","mergeArrays","arr1","arr2","getArray","array","executeMeasure","callback","start","performance","now","result","executeCallback","Promise","executePromise","setOnSetup","setup","id","parseLogProperty","getSetupBuilder","initSetup","props","withLevel","withReporters","reporters","withExtensions","extensions","clearReporters","clearExtensions","save","getLogger","init","instance","moduleName","method","map","Map","set","updateMap","configure","newSetup","debug","message","log","warn","info","error","exception","name","measure","options","time","fixedTime","toFixed","fraction","label","e","rethrow","logLevel","includes","forEach","extendMap","timestamp","Date","all","p","console","pushLog","buildMessage","data","placeholder","leftSeparator","rightSeprator","join","mergeProps","val","toLocaleString","has","separator","_setup","printStack"],"mappings":"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","file":"logger.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdLogger\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdLogger\"] = factory();\n\telse\n\t\troot[\"bpdLogger\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type LogProperty = string | (() => string) | undefined;\r\nexport type MeasureCallbackType<T> = (() => T) | Promise<T>;\r\n\r\nexport interface Log {\r\n\tprops: Map<string, LogProperty>;\r\n\ttimestamp: Date;\r\n\tlevel: LogLevel;\r\n\terror?: Error | string;\r\n}\r\n\r\nexport const PROPERTIES = {\r\n\tMESSAGE: \"message\",\r\n\tID: \"id\",\r\n\tMODULE: \"module\",\r\n\tMETHOD: \"method\",\r\n\tPERFORFMANCE: \"performance\",\r\n};\r\n\r\nexport interface LoggerMeasureOptions {\r\n\tlabel?: string;\r\n\tfraction?: number;\r\n\trethrow?: boolean;\r\n}\r\n\r\nexport interface LoggerReporter {\r\n\t(logObj: Log): Promise<boolean>;\r\n}\r\n\r\nexport interface LoggerExtension {\r\n\t(): [string, LogProperty];\r\n}\r\n\r\nexport type LogLevel =\r\n\t| \"debug\"\r\n\t| \"info\"\r\n\t| \"warn\"\r\n\t| \"error\"\r\n\t| \"exception\"\r\n\t| \"none\";\r\n\r\nexport interface LoggerSetup {\r\n\treporters?: LoggerReporter[];\r\n\textensions?: LoggerExtension[];\r\n}\r\n\r\nexport interface ISetupBuilder {\r\n\t/**\r\n\t * Sets logging level in setup\r\n\t * @param {LogLevel} level\r\n\t * @returns new bulder instance with changed logging level\r\n\t */\r\n\twithLevel(level: LogLevel): ISetupBuilder;\r\n\t/**\r\n\t * Sets reporters on in setup\r\n\t * NOTE: Reporters are added to existing\r\n\t * @param {LoggerReporter[]} reporters list of reporters\r\n\t * @returns new instance of bulder\r\n\t */\r\n\twithReporters(...reporters: LoggerReporter[]): ISetupBuilder;\r\n\t/**\r\n\t * Adds extensions to setup\r\n\t * @param {LoggerExtension} extensions list of extensions\r\n\t * @returns new instance of bulder\r\n\t */\r\n\twithExtensions(...extensions: LoggerExtension[]): ISetupBuilder;\r\n\t/**\r\n\t * Clears list of reporters in setup\r\n\t * @returns new instance of bulder\r\n\t */\r\n\tclearReporters(): ISetupBuilder;\r\n\t/**\r\n\t * Clears list of extensions\r\n\t * @returns new instance of bulder\r\n\t */\r\n\tclearExtensions(): ISetupBuilder;\r\n\t/**\r\n\t * Spawns new instance of logger with updated setup\r\n\t * @returns\r\n\t */\r\n\tsave(): Logger;\r\n}\r\n\r\nexport interface Logger {\r\n\t/**\r\n\t * Sets an id property\r\n\t * @param {string} id - any identifier string\r\n\t * @returns new instance with id property\r\n\t */\r\n\tid: (id: string) => Logger;\r\n\t/**\r\n\t * Sets an module property\r\n\t * @param {string} module - any module string\r\n\t * @returns new instance with module property\r\n\t */\r\n\tmodule: (moduleName: string) => Logger;\r\n\t/**\r\n\t * Sets an method name property\r\n\t * @param {string} method - any method string\r\n\t * @returns new instance with method property\r\n\t */\r\n\tmethod: (fName: string) => Logger;\r\n\t/**\r\n\t * Sets any property\r\n\t * @param {string} prop property name\r\n\t * @param {LogProperty} value property value\r\n\t * @returns new logger instance\r\n\t */\r\n\tprop: (prop: string, value: LogProperty) => Logger;\r\n\t/**\r\n\t * Creates a configuration builder\r\n\t * @param {LoggerSetup} newSetup (optional)\r\n\t * @returns setup builder instance\r\n\t */\r\n\tconfigure: (setup?: LoggerSetup) => ISetupBuilder;\r\n\t/**\r\n\t * Logs message on debug level\r\n\t * @param {string} message\r\n\t * @returns new Logger instance\r\n\t */\r\n\tdebug: (message?: LogProperty) => Promise<boolean>;\r\n\t/**\r\n\t * Logs message on info level\r\n\t * @param {string} message\r\n\t * @returns new Logger instance\r\n\t */\r\n\tinfo: (message?: LogProperty) => Promise<boolean>;\r\n\r\n\t/**\r\n\t * Logs message on warn level\r\n\t * @param {string} message\r\n\t * @returns new Logger instance\r\n\t */\r\n\twarn: (message?: LogProperty) => Promise<boolean>;\r\n\t/**\r\n\t * Logs message on error level\r\n\t * @param {string} message\r\n\t * @returns new Logger instance\r\n\t */\r\n\terror: (message?: LogProperty) => Promise<boolean>;\r\n\t/**\r\n\t * Logs message on exception level\r\n\t * @param {string} message\r\n\t * @returns new Logger instance\r\n\t */\r\n\texception: (error: Error | string) => Promise<boolean>;\r\n\t/**\r\n\t * Logs message on specific level\r\n\t * @param {LogLevel} logLevel level that messsage shall be logged on\r\n\t * @param {string} message\r\n\t * @param {Error} error (optional) in case of an exception\r\n\t * @returns\r\n\t */\r\n\tmeasure: <T>(\r\n\t\tcallback: MeasureCallbackType<T>,\r\n\t\toptions?: LoggerMeasureOptions\r\n\t) => Promise<T | null>;\r\n\t/**\r\n\t * Logs message on specific level\r\n\t * @param {LogLevel} logLevel level that messsage shall be logged on\r\n\t * @param {string} message\r\n\t * @param {Error} error (optional) in case of an exception\r\n\t * @returns\r\n\t */\r\n\tlog: (\r\n\t\tlevel: LogLevel,\r\n\t\tmessage?: LogProperty,\r\n\t\terror?: Error | string\r\n\t) => Promise<boolean>;\r\n}\r\n\r\n/**\r\n * Checks whether coming message log level matches level set in library\r\n * @param {LogLevel} level - current log level\r\n * @param {LogLevel} systemLevel - log level set in library\r\n * @returns whether current log level matches system level\r\n */\r\nexport function matchesLevel(level: LogLevel, systemLevel: LogLevel): boolean {\r\n\tif (level === systemLevel) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif (systemLevel === \"debug\") {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif (systemLevel === \"none\") {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tconst levelIdx = levels.findIndex((l) => l === level);\r\n\tconst sysIdx = levels.findIndex((l) => l === systemLevel);\r\n\treturn levelIdx <= sysIdx;\r\n}\r\n\r\n/**\r\n * Extends property map with props returned by extension\r\n * @param {Map<string, LogProperty>} map - property map\r\n * @param {LoggerExtension[]} extensions - logger extensions\r\n * @returns extended map\r\n */\r\nfunction extendMap(\r\n\tmap: Map<string, LogProperty>,\r\n\textensions?: LoggerExtension[]\r\n) {\r\n\tif (!extensions) {\r\n\t\treturn map;\r\n\t}\r\n\textensions.forEach((e) => map.set(...e()));\r\n\treturn map;\r\n}\r\n\r\n/**\r\n * Pushes log object to reporters\r\n * @param {LogLevel} level - log message level\r\n * @param {Map<string, LogProperty>} props - log properties\r\n * @param {LoggerReporter[]} reporters - logger reporters\r\n * @param {Error} error - (optional) - exception object\r\n * @returns whether push succeeded or not\r\n */\r\nasync function pushLog(\r\n\tlevel: LogLevel,\r\n\tprops: Map<string, LogProperty>,\r\n\treporters?: LoggerReporter[],\r\n\terror?: Error | string\r\n): Promise<boolean> {\r\n\tif (!reporters) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\ttry {\r\n\t\tconst timestamp = new Date();\r\n\t\tawait Promise.all(\r\n\t\t\treporters.map((p) =>\r\n\t\t\t\tp({\r\n\t\t\t\t\tprops,\r\n\t\t\t\t\ttimestamp,\r\n\t\t\t\t\tlevel,\r\n\t\t\t\t\terror,\r\n\t\t\t\t})\r\n\t\t\t)\r\n\t\t);\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Merges two array into one\r\n * @param {T[]} arr1 - first array\r\n * @param {T[]} arr2 - second array\r\n * @returns new array\r\n */\r\nfunction mergeArrays<T>(arr1: T[], arr2: T[]): T[] {\r\n\treturn [...arr1, ...arr2];\r\n}\r\n\r\n/**\r\n *\r\n * @param array - {optional}\r\n * @returns array or empty array when it doesnt exist\r\n */\r\nfunction getArray<T>(array?: T[]): T[] {\r\n\treturn array ? array : [];\r\n}\r\n\r\nasync function executeCallback<T>(callback: () => T): Promise<[number, T]> {\r\n\tconst start = performance.now();\r\n\tconst result = callback();\r\n\treturn [performance.now() - start, result];\r\n}\r\n\r\nasync function executePromise<T>(callback: Promise<T>): Promise<[number, T]> {\r\n\tconst start = performance.now();\r\n\tconst result = await callback;\r\n\treturn [performance.now() - start, result];\r\n}\r\n\r\nasync function executeMeasure<T>(\r\n\tcallback: MeasureCallbackType<T>\r\n): Promise<[number, T]> {\r\n\tif (typeof callback === \"function\") {\r\n\t\treturn executeCallback(callback);\r\n\t}\r\n\tif (callback instanceof Promise) {\r\n\t\treturn executePromise(callback);\r\n\t}\r\n\r\n\treturn [0, callback];\r\n}\r\n\r\n/**\r\n * Creates copy of setup object with new property set\r\n * @param {LoggerSetup} setup - setup object\r\n * @param {string} id - setup property key\r\n * @param {any} value - value to be set on the object\r\n * @returns new setup object\r\n */\r\nfunction setOnSetup(\r\n\tsetup: LoggerSetup,\r\n\tid: keyof LoggerSetup,\r\n\tvalue: any\r\n): LoggerSetup {\r\n\treturn {\r\n\t\t...setup,\r\n\t\t[id]: value,\r\n\t};\r\n}\r\n\r\n/**\r\n * Parses log property into string\r\n * @param {LogProperty} prop - log property\r\n * @returns\r\n */\r\nexport function parseLogProperty(prop: LogProperty): string | undefined {\r\n\tif (typeof prop === \"function\") {\r\n\t\treturn prop();\r\n\t}\r\n\treturn prop;\r\n}\r\n\r\n/**\r\n * Creates a logger setup builder\r\n * @param {LoggerSetup} initSetup - initial logger setup\r\n * @param {Map<string, LogProperty>} props - logger properties\r\n * @param {LogLevel} level - logging level\r\n * @returns new builder instance\r\n */\r\nexport function getSetupBuilder(\r\n\tinitSetup: LoggerSetup,\r\n\tprops: Map<string, LogProperty>,\r\n\tlevel: LogLevel\r\n): ISetupBuilder {\r\n\tconst builder: ISetupBuilder = {\r\n\t\twithLevel: (level: LogLevel) => {\r\n\t\t\treturn getSetupBuilder({ ...initSetup }, props, level);\r\n\t\t},\r\n\t\twithReporters: (...reporters: LoggerReporter[]) => {\r\n\t\t\tconst array = mergeArrays<LoggerReporter>(\r\n\t\t\t\tgetArray(initSetup.reporters),\r\n\t\t\t\treporters\r\n\t\t\t);\r\n\t\t\treturn getSetupBuilder(\r\n\t\t\t\tsetOnSetup(initSetup, \"reporters\", array),\r\n\t\t\t\tprops,\r\n\t\t\t\tlevel\r\n\t\t\t);\r\n\t\t},\r\n\t\twithExtensions: (...extensions: LoggerExtension[]) => {\r\n\t\t\tconst array = mergeArrays(\r\n\t\t\t\tgetArray(initSetup.extensions),\r\n\t\t\t\textensions\r\n\t\t\t);\r\n\t\t\treturn getSetupBuilder(\r\n\t\t\t\tsetOnSetup(initSetup, \"extensions\", array),\r\n\t\t\t\tprops,\r\n\t\t\t\tlevel\r\n\t\t\t);\r\n\t\t},\r\n\t\tclearReporters: () => {\r\n\t\t\treturn getSetupBuilder(\r\n\t\t\t\tsetOnSetup(initSetup, \"reporters\", []),\r\n\t\t\t\tprops,\r\n\t\t\t\tlevel\r\n\t\t\t);\r\n\t\t},\r\n\t\tclearExtensions: () => {\r\n\t\t\treturn getSetupBuilder(\r\n\t\t\t\tsetOnSetup(initSetup, \"extensions\", []),\r\n\t\t\t\tprops,\r\n\t\t\t\tlevel\r\n\t\t\t);\r\n\t\t},\r\n\t\tsave: () => {\r\n\t\t\treturn getLogger(initSetup, props, level);\r\n\t\t},\r\n\t};\r\n\treturn builder;\r\n}\r\n\r\n/**\r\n * Creates new logger instance\r\n * @param {LoggerSetup} setup\r\n * @param {Map<string, LogProperty>} init\r\n * @param {LogLevel} level\r\n * @returns New instance of logger\r\n */\r\nexport function getLogger(\r\n\tsetup: LoggerSetup,\r\n\tinit: Map<string, LogProperty>,\r\n\tlevel: LogLevel\r\n): Logger {\r\n\tfunction updateMap(prop: string, value: LogProperty) {\r\n\t\tconst map = new Map(init);\r\n\t\tmap.set(prop, value);\r\n\t\treturn map;\r\n\t}\r\n\r\n\tconst instance: Logger = {\r\n\t\tid: (id: string) => {\r\n\t\t\treturn instance.prop(PROPERTIES.ID, id);\r\n\t\t},\r\n\t\tmodule: (moduleName: string) => {\r\n\t\t\treturn instance.prop(PROPERTIES.MODULE, moduleName);\r\n\t\t},\r\n\t\tmethod: (method: string) => {\r\n\t\t\treturn instance.prop(PROPERTIES.METHOD, method);\r\n\t\t},\r\n\t\tprop: (prop: string, value: LogProperty) => {\r\n\t\t\treturn getLogger({ ...setup }, updateMap(prop, value), level);\r\n\t\t},\r\n\t\tconfigure: (newSetup?: LoggerSetup) => {\r\n\t\t\tconst copy = { ...setup, ...newSetup };\r\n\t\t\treturn getSetupBuilder(copy, new Map(init), level);\r\n\t\t},\r\n\t\tdebug: async (message?: LogProperty) => {\r\n\t\t\treturn instance.log(\"debug\", message);\r\n\t\t},\r\n\t\twarn: async (message?: LogProperty) => {\r\n\t\t\treturn instance.log(\"warn\", message);\r\n\t\t},\r\n\t\tinfo: async (message?: LogProperty) => {\r\n\t\t\treturn instance.log(\"info\", message);\r\n\t\t},\r\n\t\terror: async (message?: LogProperty) => {\r\n\t\t\treturn instance.log(\"error\", message);\r\n\t\t},\r\n\t\texception: async (error: Error | string) => {\r\n\t\t\treturn instance.log(\r\n\t\t\t\t\"exception\",\r\n\t\t\t\t() => {\r\n\t\t\t\t\treturn typeof error === \"string\"\r\n\t\t\t\t\t\t? error\r\n\t\t\t\t\t\t: `[${error.name}] ${error.message}`;\r\n\t\t\t\t},\r\n\t\t\t\terror\r\n\t\t\t);\r\n\t\t},\r\n\t\tmeasure: async <T>(\r\n\t\t\tcallback: MeasureCallbackType<T>,\r\n\t\t\toptions?: LoggerMeasureOptions\r\n\t\t) => {\r\n\t\t\ttry {\r\n\t\t\t\tconst [time, result] = await executeMeasure(callback);\r\n\t\t\t\tconst fixedTime = time.toFixed(options?.fraction ?? 4);\r\n\t\t\t\tinit.set(PROPERTIES.PERFORFMANCE, fixedTime);\r\n\t\t\t\tconst logResult = await instance.log(\r\n\t\t\t\t\t\"debug\",\r\n\t\t\t\t\t`${options?.label ?? \"Performance\"}: ${fixedTime}`\r\n\t\t\t\t);\r\n\t\t\t\tif (logResult) return result;\r\n\t\t\t} catch (e) {\r\n\t\t\t\tawait instance.exception(e);\r\n\t\t\t\tif (options?.rethrow === true) throw e;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\tlog: async (\r\n\t\t\tlogLevel: LogLevel,\r\n\t\t\tmessage?: LogProperty,\r\n\t\t\terror?: Error | string\r\n\t\t) => {\r\n\t\t\tif (!levels.includes(logLevel) || !matchesLevel(logLevel, level)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tconst map = new Map(init);\r\n\t\t\tif (message) map.set(PROPERTIES.MESSAGE, message);\r\n\t\t\textendMap(map, setup.extensions);\r\n\t\t\treturn pushLog(logLevel, map, setup.reporters, error);\r\n\t\t},\r\n\t};\r\n\treturn instance;\r\n}\r\n\r\nconst levels: LogLevel[] = [\r\n\t\"none\",\r\n\t\"exception\",\r\n\t\"error\",\r\n\t\"warn\",\r\n\t\"info\",\r\n\t\"debug\",\r\n];\r\n\r\nconst globalSetup: LoggerSetup = {\r\n\treporters: [],\r\n\textensions: [],\r\n};\r\n\r\nconst logger = getLogger(globalSetup, new Map(), \"none\");\r\nexport default logger;\r\n","import { Log, LoggerReporter, parseLogProperty } from \"../logger\";\r\n\r\nexport interface ConsoleLoggerInit {\r\n\tprops: string[];\r\n\tseparator?: [string, string];\r\n\tplaceholder?: string;\r\n\tprintStack?: boolean;\r\n}\r\n\r\ninterface ConsoleLoggerConfig {\r\n\tprops: string[];\r\n\tseparator: [string, string];\r\n\tplaceholder: string;\r\n\tprintStack?: boolean;\r\n}\r\n\r\n/**\r\n * Extracts values from log object\r\n * @param {Log} data - log object\r\n * @param {string[]} props - list of properties to be extracted from Log object\r\n * @param {string} placeholder - value to be set when prop was not found\r\n * @returns List of properties extracted from log object\r\n */\r\nfunction extractValuesFromLog(\r\n\tdata: Log,\r\n\tprops: string[],\r\n\tplaceholder: string\r\n): string[] {\r\n\treturn props.map((p) => {\r\n\t\tlet val = placeholder;\r\n\t\tswitch (p) {\r\n\t\t\tcase \"date\":\r\n\t\t\t\tval = data.timestamp.toLocaleString();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"level\":\r\n\t\t\t\tval = data.level;\r\n\t\t\tdefault:\r\n\t\t\t\tif (data.props.has(p)) {\r\n\t\t\t\t\tval = parseLogProperty(data.props.get(p)) ?? placeholder;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn val;\r\n\t});\r\n}\r\n\r\n/**\r\n * Merges log properties into one string\r\n * @param {string[]} props - data props\r\n * @param {string} leftSeparator - left side character\r\n * @param {string} rightSeprator - right side character\r\n * @returns props merged into string\r\n */\r\nfunction mergeProps(\r\n\tprops: string[],\r\n\tleftSeparator: string,\r\n\trightSeprator: string\r\n): string {\r\n\treturn `${leftSeparator}${props.join(\r\n\t\trightSeprator + leftSeparator\r\n\t)}${rightSeprator}`;\r\n}\r\n\r\n/**\r\n * Creates log message text\r\n * @param {Log} log - logger object\r\n * @param {ConsoleLoggerConfig} setup - reporter setup\r\n * @returns Log message\r\n */\r\nfunction buildMessage(log: Log, setup: ConsoleLoggerConfig): string {\r\n\tconst values = extractValuesFromLog(log, setup.props, setup.placeholder);\r\n\treturn mergeProps(values, setup.separator[0], setup.separator[1]);\r\n}\r\n\r\n/**\r\n * Implementaion of console log reporter\r\n * @param {ConsoleLoggerInit} init - initial setup object\r\n * @returns reporter callback\r\n */\r\nexport default function ConsoleLoggerReporter(\r\n\tinit: ConsoleLoggerInit\r\n): LoggerReporter {\r\n\tconst _setup: ConsoleLoggerConfig = {\r\n\t\t...init,\r\n\t\tseparator: init.separator ?? [\"[\", \"]\"],\r\n\t\tplaceholder: init.placeholder ?? \"-\",\r\n\t};\r\n\r\n\treturn async (log: Log) => {\r\n\t\tconst message = buildMessage(log, _setup);\r\n\t\tswitch (log.level) {\r\n\t\t\tcase \"error\":\r\n\t\t\tcase \"exception\":\r\n\t\t\t\tconsole.error(message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"warn\":\r\n\t\t\t\tconsole.warn(message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"info\":\r\n\t\t\t\tconsole.info(message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"debug\":\r\n\t\t\t\tconsole.debug(message);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(message);\r\n\t\t}\r\n\t\tif (log.error && _setup.printStack === true) {\r\n\t\t\tconsole.error(log.error);\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n}\r\n","import ConsoleReporter from \"./reporters/console\";\r\nexport * from \"./logger\";\r\nexport const ConsoleLoggerReporter = ConsoleReporter;\r\n"],"sourceRoot":""}